{
  "agent": {
    "model": {
      "provider": "claude",
      "model": "claude-3-7-sonnet"
    },
    "statistic": {
      "time": 91669,
      "tokens": 8543
    }
  },
  "question": {
    "topic": {
      "name": "SwiftUI State Management",
      "platform": "iOS",
      "technology": "Swift"
    },
    "text": "Create a SwiftUI application that implements a temperature converter between Celsius and Fahrenheit. The app should have:\n\n1. A text field for entering a temperature value\n2. A segmented control to switch between Celsius and Fahrenheit as the input unit\n3. A display showing the converted temperature in the other unit\n\nThe UI should update in real-time as the user types or changes the temperature unit. Use appropriate SwiftUI views and state management techniques to implement this functionality.",
    "tags": [
      "SwiftUI",
      "View",
      "State",
      "TextField",
      "iOS",
      "Swift",
      "Property Wrappers"
    ],
    "answerLevels": {
      "beginner": {
        "name": "Beginner",
        "answer": "For a beginner implementation, we'll use a basic approach with the `@State` property wrapper to manage the UI state.\n\n```swift\nimport SwiftUI\n\nstruct ContentView: View {\n    @State private var inputTemperature = \"\"\n    @State private var selectedUnit = 0 // 0 for Celsius, 1 for Fahrenheit\n    \n    var outputTemperature: String {\n        guard let temp = Double(inputTemperature) else {\n            return \"\"\n        }\n        \n        if selectedUnit == 0 {\n            // Convert Celsius to Fahrenheit\n            let fahrenheit = (temp * 9/5) + 32\n            return String(format: \"%.1f\u00b0F\", fahrenheit)\n        } else {\n            // Convert Fahrenheit to Celsius\n            let celsius = (temp - 32) * 5/9\n            return String(format: \"%.1f\u00b0C\", celsius)\n        }\n    }\n    \n    var body: some View {\n        VStack(spacing: 20) {\n            Text(\"Temperature Converter\")\n                .font(.largeTitle)\n                .padding()\n            \n            TextField(\"Enter temperature\", text: $inputTemperature)\n                .keyboardType(.decimalPad)\n                .textFieldStyle(RoundedBorderTextFieldStyle())\n                .padding()\n            \n            Picker(\"Unit\", selection: $selectedUnit) {\n                Text(\"Celsius\").tag(0)\n                Text(\"Fahrenheit\").tag(1)\n            }\n            .pickerStyle(SegmentedPickerStyle())\n            .padding()\n            \n            Text(\"Converted temperature: \\(outputTemperature)\")\n                .font(.title2)\n                .padding()\n            \n            Spacer()\n        }\n        .padding()\n    }\n}\n```\n\nThis implementation uses:\n- `@State` property wrapper to manage the input temperature and selected unit\n- A computed property to calculate the converted temperature\n- Basic SwiftUI views like TextField, Picker, and Text\n- The UI updates automatically when the state changes due to SwiftUI's reactive nature",
        "tests": [
          {
            "snippet": "What is the purpose of the `@State` property wrapper in this code?",
            "options": [
              "1. It creates a reference type property that can be shared across views",
              "2. It creates a value type property that the view owns and can modify, triggering UI updates",
              "3. It creates a constant property that cannot be modified after initialization",
              "4. It creates a property that persists data across app launches"
            ],
            "answer": "2"
          },
          {
            "snippet": "What will happen if the user enters \"abc\" in the temperature TextField?",
            "options": [
              "1. The app will crash with a runtime error",
              "2. The converted temperature will show \"0\u00b0F\" or \"0\u00b0C\"",
              "3. The converted temperature will be empty",
              "4. The TextField will automatically reject non-numeric input"
            ],
            "answer": "3"
          },
          {
            "snippet": "Which of the following changes would allow the keyboard to be dismissed when tapping outside the TextField?",
            "options": [
              "1. Add `.onTapGesture { UIApplication.shared.endEditing() }`",
              "2. Wrap the VStack in a `TouchDownGestureRecognizer`",
              "3. Add a `.resignFirstResponder()` modifier to the TextField",
              "4. Wrap the content in a `ScrollView` and add a `.onTapGesture { UIApplication.shared.sendAction(#selector(UIResponder.resignFirstResponder), to: nil, from: nil, for: nil) }`"
            ],
            "answer": "4"
          }
        ],
        "evaluationCriteria": "The beginner solution should be evaluated based on: 1) Correct implementation of basic state management using @State, 2) Proper UI updates when input changes, 3) Correct temperature conversion logic, 4) Basic error handling for invalid input, and 5) Appropriate use of SwiftUI views and layouts."
      },
      "intermediate": {
        "name": "Intermediate",
        "answer": "For an intermediate implementation, we'll use a more structured approach with a separate model and better state management. We'll also add more features like input validation and a more polished UI.\n\n```swift\nimport SwiftUI\nimport Combine\n\nenum TemperatureUnit: String, CaseIterable, Identifiable {\n    case celsius = \"Celsius\"\n    case fahrenheit = \"Fahrenheit\"\n    \n    var id: String { self.rawValue }\n    \n    var symbol: String {\n        switch self {\n        case .celsius: return \"\u00b0C\"\n        case .fahrenheit: return \"\u00b0F\"\n        }\n    }\n}\n\nclass TemperatureConverter: ObservableObject {\n    @Published var inputValue = \"\"\n    @Published var selectedUnit: TemperatureUnit = .celsius\n    @Published var convertedValue = \"\"\n    \n    private var cancellables = Set<AnyCancellable>()\n    \n    init() {\n        // Combine Publishers to update the converted value whenever input changes\n        Publishers.CombineLatest($inputValue, $selectedUnit)\n            .debounce(for: 0.2, scheduler: RunLoop.main) // Debounce to avoid rapid updates\n            .sink { [weak self] (input, unit) in\n                self?.updateConversion(input: input, unit: unit)\n            }\n            .store(in: &cancellables)\n    }\n    \n    private func updateConversion(input: String, unit: TemperatureUnit) {\n        guard let value = Double(input) else {\n            convertedValue = \"\"\n            return\n        }\n        \n        let result: Double\n        let resultUnit: TemperatureUnit\n        \n        if unit == .celsius {\n            // Convert Celsius to Fahrenheit\n            result = (value * 9/5) + 32\n            resultUnit = .fahrenheit\n        } else {\n            // Convert Fahrenheit to Celsius\n            result = (value - 32) * 5/9\n            resultUnit = .celsius\n        }\n        \n        convertedValue = String(format: \"%.1f%@\", result, resultUnit.symbol)\n    }\n}\n\nstruct ContentView: View {\n    @StateObject private var converter = TemperatureConverter()\n    @FocusState private var isInputFocused: Bool\n    \n    var body: some View {\n        NavigationView {\n            Form {\n                Section(header: Text(\"Input Temperature\")) {\n                    TextField(\"Enter value\", text: $converter.inputValue)\n                        .keyboardType(.decimalPad)\n                        .focused($isInputFocused)\n                    \n                    Picker(\"Unit\", selection: $converter.selectedUnit) {\n                        ForEach(TemperatureUnit.allCases) { unit in\n                            Text(unit.rawValue).tag(unit)\n                        }\n                    }\n                    .pickerStyle(SegmentedPickerStyle())\n                }\n                \n                Section(header: Text(\"Converted Temperature\")) {\n                    if !converter.convertedValue.isEmpty {\n                        Text(converter.convertedValue)\n                            .font(.title2)\n                            .padding(.vertical, 10)\n                    } else {\n                        Text(\"Enter a valid temperature\")\n                            .foregroundColor(.secondary)\n                    }\n                }\n            }\n            .navigationTitle(\"Temperature Converter\")\n            .toolbar {\n                ToolbarItemGroup(placement: .keyboard) {\n                    Spacer()\n                    Button(\"Done\") {\n                        isInputFocused = false\n                    }\n                }\n            }\n        }\n    }\n}\n```\n\nThis intermediate implementation includes:\n- A dedicated `TemperatureConverter` model using `ObservableObject`\n- An enum for temperature units with associated data\n- Combine framework for reactive updates with debouncing\n- Form-based UI with sections for better organization\n- Keyboard management with a toolbar and focus state\n- Better error handling and user feedback",
        "tests": [
          {
            "snippet": "What is the purpose of using `@StateObject` instead of `@ObservedObject` for the converter property?",
            "options": [
              "1. It's just a naming convention with no functional difference",
              "2. @StateObject ensures the converter is created and owned by the view and persists across view updates",
              "3. @StateObject allows the converter to be shared with other views",
              "4. @StateObject provides better performance for complex calculations"
            ],
            "answer": "2"
          },
          {
            "snippet": "What does the `.debounce(for: 0.2, scheduler: RunLoop.main)` do in the Combine pipeline?",
            "options": [
              "1. It delays UI updates by 0.2 seconds",
              "2. It waits until the user has stopped typing for 0.2 seconds before processing the input",
              "3. It throttles input to improve performance",
              "4. It schedules the conversion to run on a background thread"
            ],
            "answer": "2"
          },
          {
            "snippet": "What is the purpose of the `@FocusState` property in this implementation?",
            "options": [
              "1. It tracks whether the keyboard is visible",
              "2. It manages the focus state of the text field to programmatically show or hide the keyboard",
              "3. It highlights the active section in the form",
              "4. It tracks whether the user is currently entering a temperature value"
            ],
            "answer": "2"
          }
        ],
        "evaluationCriteria": "The intermediate solution should be evaluated based on: 1) Proper separation of concerns using MVVM pattern, 2) Effective use of Combine for reactive updates, 3) Proper use of ObservableObject and StateObject, 4) Enhanced UI with Form and navigation elements, 5) Proper keyboard handling, 6) Appropriate use of enums for type safety, and 7) Implementation of debouncing for better user experience."
      },
      "advanced": {
        "name": "Advanced",
        "answer": "For an advanced implementation, we'll create a comprehensive solution with multiple temperature scales, localization support, history tracking, and accessibility features. We'll use a more sophisticated architecture pattern.\n\n```swift\nimport SwiftUI\nimport Combine\n\n// MARK: - Models\n\nenum TemperatureUnit: String, CaseIterable, Identifiable {\n    case celsius = \"Celsius\"\n    case fahrenheit = \"Fahrenheit\"\n    case kelvin = \"Kelvin\"\n    \n    var id: String { self.rawValue }\n    \n    var symbol: String {\n        switch self {\n        case .celsius: return \"\u00b0C\"\n        case .fahrenheit: return \"\u00b0F\"\n        case .kelvin: return \"K\"\n        }\n    }\n    \n    var localizedName: String {\n        NSLocalizedString(self.rawValue, comment: \"Temperature unit\")\n    }\n}\n\nstruct ConversionRecord: Identifiable, Codable {\n    let id = UUID()\n    let timestamp: Date\n    let inputValue: Double\n    let inputUnit: String\n    let outputValue: Double\n    let outputUnit: String\n    \n    var formattedDate: String {\n        let formatter = DateFormatter()\n        formatter.dateStyle = .short\n        formatter.timeStyle = .short\n        return formatter.string(from: timestamp)\n    }\n}\n\n// MARK: - View Model\n\nclass TemperatureViewModel: ObservableObject {\n    // Published properties\n    @Published var inputValue = \"\"\n    @Published var selectedInputUnit: TemperatureUnit = .celsius\n    @Published var selectedOutputUnit: TemperatureUnit = .fahrenheit\n    @Published var conversionHistory: [ConversionRecord] = []\n    @Published var showHistory = false\n    \n    // Computed properties\n    var outputValue: String {\n        guard let value = Double(inputValue) else { return \"\" }\n        let convertedValue = convert(value: value, from: selectedInputUnit, to: selectedOutputUnit)\n        return String(format: \"%.2f%@\", convertedValue, selectedOutputUnit.symbol)\n    }\n    \n    var formattedInput: String {\n        guard let value = Double(inputValue) else { return \"\" }\n        return String(format: \"%.2f%@\", value, selectedInputUnit.symbol)\n    }\n    \n    // Private properties\n    private var cancellables = Set<AnyCancellable>()\n    private let historyKey = \"conversionHistory\"\n    \n    init() {\n        loadHistory()\n        setupPublishers()\n    }\n    \n    private func setupPublishers() {\n        // Update history when a valid conversion happens\n        Publishers.CombineLatest3($inputValue, $selectedInputUnit, $selectedOutputUnit)\n            .debounce(for: 0.5, scheduler: RunLoop.main)\n            .sink { [weak self] (input, inputUnit, outputUnit) in\n                guard let self = self, let inputValue = Double(input), !input.isEmpty else { return }\n                let outputValue = self.convert(value: inputValue, from: inputUnit, to: outputUnit)\n                self.addToHistory(input: inputValue, inputUnit: inputUnit, output: outputValue, outputUnit: outputUnit)\n            }\n            .store(in: &cancellables)\n    }\n    \n    // MARK: - Conversion Logic\n    \n    func convert(value: Double, from inputUnit: TemperatureUnit, to outputUnit: TemperatureUnit) -> Double {\n        // First convert to Kelvin (our base unit)\n        let kelvinValue: Double\n        switch inputUnit {\n        case .celsius:\n            kelvinValue = value + 273.15\n        case .fahrenheit:\n            kelvinValue = (value - 32) * 5/9 + 273.15\n        case .kelvin:\n            kelvinValue = value\n        }\n        \n        // Then convert from Kelvin to target unit\n        switch outputUnit {\n        case .celsius:\n            return kelvinValue - 273.15\n        case .fahrenheit:\n            return (kelvinValue - 273.15) * 9/5 + 32\n        case .kelvin:\n            return kelvinValue\n        }\n    }\n    \n    // MARK: - History Management\n    \n    private func addToHistory(input: Double, inputUnit: TemperatureUnit, output: Double, outputUnit: TemperatureUnit) {\n        let record = ConversionRecord(\n            timestamp: Date(),\n            inputValue: input,\n            inputUnit: inputUnit.rawValue,\n            outputValue: output,\n            outputUnit: outputUnit.rawValue\n        )\n        \n        conversionHistory.insert(record, at: 0)\n        if conversionHistory.count > 10 {\n            conversionHistory = Array(conversionHistory.prefix(10))\n        }\n        saveHistory()\n    }\n    \n    private func saveHistory() {\n        if let encoded = try? JSONEncoder().encode(conversionHistory) {\n            UserDefaults.standard.set(encoded, forKey: historyKey)\n        }\n    }\n    \n    private func loadHistory() {\n        if let data = UserDefaults.standard.data(forKey: historyKey),\n           let history = try? JSONDecoder().decode([ConversionRecord].self, from: data) {\n            conversionHistory = history\n        }\n    }\n    \n    func clearHistory() {\n        conversionHistory.removeAll()\n        UserDefaults.standard.removeObject(forKey: historyKey)\n    }\n    \n    // MARK: - Utility Methods\n    \n    func swapUnits() {\n        let temp = selectedInputUnit\n        selectedInputUnit = selectedOutputUnit\n        selectedOutputUnit = temp\n    }\n}\n\n// MARK: - Views\n\nstruct TemperatureConverterView: View {\n    @StateObject private var viewModel = TemperatureViewModel()\n    @FocusState private var isInputFocused: Bool\n    @Environment(\\.colorScheme) private var colorScheme\n    \n    var body: some View {\n        NavigationView {\n            List {\n                // Input Section\n                Section {\n                    VStack(alignment: .leading) {\n                        Text(\"Enter Temperature\")\n                            .font(.caption)\n                            .foregroundColor(.secondary)\n                        \n                        HStack {\n                            TextField(\"Value\", text: $viewModel.inputValue)\n                                .keyboardType(.decimalPad)\n                                .focused($isInputFocused)\n                                .accessibilityLabel(\"Temperature input field\")\n                            \n                            Picker(\"Unit\", selection: $viewModel.selectedInputUnit) {\n                                ForEach(TemperatureUnit.allCases) { unit in\n                                    Text(unit.localizedName).tag(unit)\n                                }\n                            }\n                            .pickerStyle(MenuPickerStyle())\n                            .accessibilityLabel(\"Input unit picker\")\n                        }\n                    }\n                    .padding(.vertical, 8)\n                }\n                \n                // Unit Swap Button\n                Section {\n                    Button(action: viewModel.swapUnits) {\n                        HStack {\n                            Spacer()\n                            Image(systemName: \"arrow.up.arrow.down\")\n                                .font(.title2)\n                                .foregroundColor(.blue)\n                            Text(\"Swap Units\")\n                                .font(.headline)\n                            Spacer()\n                        }\n                    }\n                    .buttonStyle(BorderlessButtonStyle())\n                    .accessibilityLabel(\"Swap input and output units\")\n                }\n                \n                // Output Section\n                Section {\n                    VStack(alignment: .leading) {\n                        HStack {\n                            Text(\"Convert To:\")\n                                .font(.caption)\n                                .foregroundColor(.secondary)\n                            \n                            Picker(\"Output Unit\", selection: $viewModel.selectedOutputUnit) {\n                                ForEach(TemperatureUnit.allCases) { unit in\n                                    Text(unit.localizedName).tag(unit)\n                                }\n                            }\n                            .pickerStyle(MenuPickerStyle())\n                            .accessibilityLabel(\"Output unit picker\")\n                        }\n                        \n                        if !viewModel.outputValue.isEmpty {\n                            HStack {\n                                Spacer()\n                                Text(viewModel.outputValue)\n                                    .font(.system(size: 36, weight: .bold, design: .rounded))\n                                    .foregroundColor(.primary)\n                                    .padding(.vertical, 10)\n                                    .accessibilityLabel(\"Converted temperature: \\(viewModel.outputValue)\")\n                                Spacer()\n                            }\n                        }\n                    }\n                    .padding(.vertical, 8)\n                }\n                \n                // Conversion Details\n                if !viewModel.formattedInput.isEmpty && !viewModel.outputValue.isEmpty {\n                    Section(header: Text(\"Conversion Details\")) {\n                        VStack(alignment: .leading, spacing: 8) {\n                            Text(\"\\(viewModel.formattedInput) = \\(viewModel.outputValue)\")\n                                .font(.body)\n                            \n                            Text(\"Formula: \\(conversionFormula(from: viewModel.selectedInputUnit, to: viewModel.selectedOutputUnit))\")\n                                .font(.caption)\n                                .foregroundColor(.secondary)\n                        }\n                        .padding(.vertical, 4)\n                    }\n                }\n            }\n            .navigationTitle(\"Temperature Converter\")\n            .toolbar {\n                ToolbarItem(placement: .navigationBarTrailing) {\n                    Button(action: { viewModel.showHistory.toggle() }) {\n                        Image(systemName: \"clock.arrow.circlepath\")\n                    }\n                    .accessibilityLabel(\"Show conversion history\")\n                }\n                \n                ToolbarItemGroup(placement: .keyboard) {\n                    Spacer()\n                    Button(\"Done\") {\n                        isInputFocused = false\n                    }\n                }\n            }\n            .sheet(isPresented: $viewModel.showHistory) {\n                HistoryView(history: viewModel.conversionHistory, clearHistory: viewModel.clearHistory)\n            }\n        }\n    }\n    \n    private func conversionFormula(from input: TemperatureUnit, to output: TemperatureUnit) -> String {\n        switch (input, output) {\n        case (.celsius, .fahrenheit):\n            return \"\u00b0F = (\u00b0C \u00d7 9/5) + 32\"\n        case (.fahrenheit, .celsius):\n            return \"\u00b0C = (\u00b0F - 32) \u00d7 5/9\"\n        case (.celsius, .kelvin):\n            return \"K = \u00b0C + 273.15\"\n        case (.kelvin, .celsius):\n            return \"\u00b0C = K - 273.15\"\n        case (.fahrenheit, .kelvin):\n            return \"K = (\u00b0F - 32) \u00d7 5/9 + 273.15\"\n        case (.kelvin, .fahrenheit):\n            return \"\u00b0F = (K - 273.15) \u00d7 9/5 + 32\"\n        default:\n            return \"No conversion needed\"\n        }\n    }\n}\n\nstruct HistoryView: View {\n    let history: [ConversionRecord]\n    let clearHistory: () -> Void\n    \n    var body: some View {\n        NavigationView {\n            List {\n                if history.isEmpty {\n                    Text(\"No conversion history yet\")\n                        .foregroundColor(.secondary)\n                        .frame(maxWidth: .infinity, alignment: .center)\n                        .padding()\n                } else {\n                    ForEach(history) { record in\n                        VStack(alignment: .leading, spacing: 4) {\n                            Text(\"\\(String(format: \"%.2f\", record.inputValue)) \\(record.inputUnit) \u2192 \\(String(format: \"%.2f\", record.outputValue)) \\(record.outputUnit)\")\n                                .font(.headline)\n                            \n                            Text(record.formattedDate)\n                                .font(.caption)\n                                .foregroundColor(.secondary)\n                        }\n                        .padding(.vertical, 4)\n                    }\n                }\n            }\n            .navigationTitle(\"Conversion History\")\n            .navigationBarTitleDisplayMode(.inline)\n            .toolbar {\n                ToolbarItem(placement: .navigationBarTrailing) {\n                    Button(\"Clear\") {\n                        clearHistory()\n                    }\n                    .disabled(history.isEmpty)\n                }\n                \n                ToolbarItem(placement: .navigationBarLeading) {\n                    Button(\"Close\") {\n                        // This will be handled by the sheet's isPresented binding\n                    }\n                }\n            }\n        }\n    }\n}\n```\n\nThis advanced implementation includes:\n\n1. **Comprehensive Architecture**:\n   - Follows MVVM pattern with clear separation of concerns\n   - Uses Combine for reactive programming\n   - Proper state management with @Published properties\n\n2. **Enhanced Features**:\n   - Support for multiple temperature units (Celsius, Fahrenheit, Kelvin)\n   - Conversion history tracking with persistence\n   - Unit swapping functionality\n   - Detailed conversion information\n   - Localization support\n\n3. **Improved UX/UI**:\n   - Responsive layout with proper spacing and typography\n   - Accessibility labels for screen readers\n   - Keyboard management\n   - History view in a sheet\n   - Formula display for educational purposes\n\n4. **Best Practices**:\n   - Memory management with weak self references\n   - Error handling for invalid inputs\n   - Debouncing for performance\n   - Persistence using UserDefaults\n   - Proper use of Swift language features like enums and computed properties",
        "tests": [
          {
            "snippet": "What architectural pattern is used in this implementation, and how does it help with the app's design?",
            "options": [
              "1. MVC (Model-View-Controller) - It separates the UI from the data model",
              "2. MVVM (Model-View-ViewModel) - It provides a clear separation of concerns with reactive updates between the view and business logic",
              "3. Clean Architecture - It uses multiple layers with dependency injection",
              "4. Redux - It manages state through a central store with reducers"
            ],
            "answer": "2"
          },
          {
            "snippet": "Examine this code from the ViewModel:\n```swift\nfunc convert(value: Double, from inputUnit: TemperatureUnit, to outputUnit: TemperatureUnit) -> Double {\n    // First convert to Kelvin (our base unit)\n    let kelvinValue: Double\n    switch inputUnit {\n    case .celsius:\n        kelvinValue = value + 273.15\n    case .fahrenheit:\n        kelvinValue = (value - 32) * 5/9 + 273.15\n    case .kelvin:\n        kelvinValue = value\n    }\n    \n    // Then convert from Kelvin to target unit\n    switch outputUnit {\n    case .celsius:\n        return kelvinValue - 273.15\n    case .fahrenheit:\n        return (kelvinValue - 273.15) * 9/5 + 32\n    case .kelvin:\n        return kelvinValue\n    }\n}\n```\nWhat design pattern is being used in this conversion method?",
            "options": [
              "1. Strategy Pattern - Different algorithms are selected at runtime",
              "2. Adapter Pattern - Converting between different interfaces",
              "3. Canonical Form Pattern - Converting to a standard form before final conversion",
              "4. Command Pattern - Encapsulating conversion requests as objects"
            ],
            "answer": "3"
          },
          {
            "snippet": "What would be a potential improvement to make this code more testable?",
            "options": [
              "1. Move the conversion logic to a separate service that can be injected into the ViewModel",
              "2. Add more comments to explain the conversion formulas",
              "3. Use more computed properties instead of functions",
              "4. Replace Combine with async/await for better readability"
            ],
            "answer": "1"
          }
        ],
        "evaluationCriteria": "The advanced solution should be evaluated based on: 1) Proper architecture with clear separation of concerns, 2) Use of advanced Swift features like Combine, property wrappers, and protocols, 3) Implementation of additional features like history tracking and multiple units, 4) Proper persistence of data, 5) Accessibility considerations, 6) Code organization and maintainability, 7) Error handling and edge cases, 8) Localization support, and 9) Performance optimizations like debouncing."
      }
    }
  }
}