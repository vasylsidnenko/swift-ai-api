{
  "agent": {
    "model": {
      "provider": "claude",
      "model": "claude-3-7-sonnet"
    },
    "statistic": {
      "time": 80563,
      "tokens": 7615
    }
  },
  "question": {
    "topic": {
      "name": "SwiftUI State Management",
      "platform": "iOS",
      "technology": "Swift"
    },
    "text": "Create a temperature converter application in SwiftUI that allows users to convert between Celsius and Fahrenheit. The app should include:\n\n1. A text field for entering a temperature value\n2. A segmented control to select the input temperature unit (Celsius or Fahrenheit)\n3. A display showing the converted temperature value\n\nThe UI should update in real-time as the user types or changes the temperature unit. Use appropriate SwiftUI state management concepts to handle the data flow.",
    "tags": [
      "SwiftUI",
      "View",
      "State",
      "Binding",
      "iOS",
      "Swift",
      "StateObject",
      "ObservableObject"
    ],
    "answerLevels": {
      "beginner": {
        "name": "Beginner",
        "answer": "For a beginner implementation, we'll use the basic `@State` property wrapper to manage the state within a single view.\n\n```swift\nimport SwiftUI\n\nstruct ContentView: View {\n    @State private var inputTemperature = \"\"\n    @State private var selectedUnit = 0 // 0 for Celsius, 1 for Fahrenheit\n    \n    private var convertedTemperature: String {\n        guard let temp = Double(inputTemperature) else {\n            return \"Invalid input\"\n        }\n        \n        if selectedUnit == 0 {\n            // Convert from Celsius to Fahrenheit\n            let fahrenheit = temp * 9/5 + 32\n            return String(format: \"%.1f\u00b0F\", fahrenheit)\n        } else {\n            // Convert from Fahrenheit to Celsius\n            let celsius = (temp - 32) * 5/9\n            return String(format: \"%.1f\u00b0C\", celsius)\n        }\n    }\n    \n    var body: some View {\n        VStack(spacing: 20) {\n            Text(\"Temperature Converter\")\n                .font(.largeTitle)\n                .padding()\n            \n            TextField(\"Enter temperature\", text: $inputTemperature)\n                .keyboardType(.decimalPad)\n                .textFieldStyle(RoundedBorderTextFieldStyle())\n                .padding()\n            \n            Picker(\"Temperature Unit\", selection: $selectedUnit) {\n                Text(\"Celsius\").tag(0)\n                Text(\"Fahrenheit\").tag(1)\n            }\n            .pickerStyle(SegmentedPickerStyle())\n            .padding()\n            \n            Text(\"Converted temperature:\")\n                .font(.headline)\n            \n            Text(convertedTemperature)\n                .font(.largeTitle)\n                .padding()\n            \n            Spacer()\n        }\n        .padding()\n    }\n}\n```\n\nIn this implementation:\n\n1. We use `@State` to track the input temperature string and the selected unit.\n2. A computed property calculates the converted temperature.\n3. The UI updates automatically when the state variables change because SwiftUI knows to redraw the view when `@State` properties change.",
        "tests": [
          {
            "snippet": "What happens when the user types a new value in the TextField?",
            "options": [
              "1. Nothing happens until the user presses a Convert button",
              "2. The view automatically updates with the new converted temperature",
              "3. The app crashes because we need to handle the TextField's onChange event"
            ],
            "answer": "2"
          },
          {
            "snippet": "What is the purpose of the `$` symbol in `$inputTemperature` when used with the TextField?",
            "options": [
              "1. It creates a two-way binding to the state variable",
              "2. It formats the number as a currency value",
              "3. It marks the variable as private"
            ],
            "answer": "1"
          },
          {
            "snippet": "If we wanted to add a button to reset the input temperature to zero, which code would be correct?",
            "options": [
              "1. `Button(\"Reset\") { inputTemperature = 0 }`",
              "2. `Button(\"Reset\") { inputTemperature = \"0\" }`",
              "3. `Button(\"Reset\") { $inputTemperature = \"0\" }`"
            ],
            "answer": "2"
          }
        ],
        "evaluationCriteria": "The beginner solution should correctly implement the temperature converter using basic SwiftUI state management with `@State` properties. The solution should handle user input, update the UI reactively, and perform the correct temperature conversion calculations. The code should be clean, well-structured, and follow SwiftUI best practices for a single-view application."
      },
      "intermediate": {
        "name": "Intermediate",
        "answer": "For an intermediate implementation, we'll use the MVVM pattern with an `ObservableObject` to separate the business logic from the view.\n\n```swift\nimport SwiftUI\nimport Combine\n\n// Model\nenum TemperatureUnit: Int, CaseIterable, Identifiable {\n    case celsius = 0\n    case fahrenheit = 1\n    \n    var id: Int { self.rawValue }\n    \n    var symbol: String {\n        switch self {\n        case .celsius: return \"\u00b0C\"\n        case .fahrenheit: return \"\u00b0F\"\n        }\n    }\n    \n    var name: String {\n        switch self {\n        case .celsius: return \"Celsius\"\n        case .fahrenheit: return \"Fahrenheit\"\n        }\n    }\n}\n\n// ViewModel\nclass TemperatureConverter: ObservableObject {\n    @Published var inputTemperature: String = \"\"\n    @Published var selectedUnit: TemperatureUnit = .celsius\n    \n    var convertedTemperature: String {\n        guard let temp = Double(inputTemperature) else {\n            return \"Invalid input\"\n        }\n        \n        switch selectedUnit {\n        case .celsius:\n            // Convert from Celsius to Fahrenheit\n            let fahrenheit = temp * 9/5 + 32\n            return String(format: \"%.1f\u00b0F\", fahrenheit)\n        case .fahrenheit:\n            // Convert from Fahrenheit to Celsius\n            let celsius = (temp - 32) * 5/9\n            return String(format: \"%.1f\u00b0C\", celsius)\n        }\n    }\n    \n    func reset() {\n        inputTemperature = \"\"\n    }\n}\n\n// View\nstruct ContentView: View {\n    @StateObject private var converter = TemperatureConverter()\n    \n    var body: some View {\n        NavigationView {\n            VStack(spacing: 20) {\n                TextField(\"Enter temperature\", text: $converter.inputTemperature)\n                    .keyboardType(.decimalPad)\n                    .textFieldStyle(RoundedBorderTextFieldStyle())\n                    .padding()\n                \n                Picker(\"Temperature Unit\", selection: $converter.selectedUnit) {\n                    ForEach(TemperatureUnit.allCases) { unit in\n                        Text(unit.name).tag(unit)\n                    }\n                }\n                .pickerStyle(SegmentedPickerStyle())\n                .padding()\n                \n                Text(\"Converted temperature:\")\n                    .font(.headline)\n                \n                Text(converter.convertedTemperature)\n                    .font(.largeTitle)\n                    .padding()\n                \n                Button(\"Reset\") {\n                    converter.reset()\n                }\n                .buttonStyle(.bordered)\n                \n                Spacer()\n            }\n            .padding()\n            .navigationTitle(\"Temperature Converter\")\n        }\n    }\n}\n```\n\nIn this intermediate implementation:\n\n1. We use the MVVM pattern with a `TemperatureConverter` class as the ViewModel.\n2. The ViewModel uses `@Published` properties to notify the View of changes.\n3. We create a proper enum for the temperature units with useful properties.\n4. The View uses `@StateObject` to manage the lifecycle of the ViewModel.\n5. We've added a reset function to demonstrate methods in the ViewModel.\n6. The UI is enhanced with a NavigationView and proper styling.",
        "tests": [
          {
            "snippet": "What is the purpose of the `@Published` property wrapper in the ViewModel?",
            "options": [
              "1. It makes the property private to the ViewModel",
              "2. It notifies observers when the property changes",
              "3. It saves the property value to UserDefaults"
            ],
            "answer": "2"
          },
          {
            "snippet": "Which of the following statements about `@StateObject` is correct?",
            "options": [
              "1. It's identical to `@ObservedObject` in all ways",
              "2. It preserves the object instance when the view is redrawn",
              "3. It's used only for primitive types like Int and String"
            ],
            "answer": "2"
          },
          {
            "snippet": "If we wanted to add input validation to ensure only numbers are entered, where should this logic be placed?",
            "options": [
              "1. In the View's body property",
              "2. In the ViewModel",
              "3. In a separate UIKit controller"
            ],
            "answer": "2"
          }
        ],
        "evaluationCriteria": "The intermediate solution should implement the MVVM architecture pattern with a proper separation of concerns. The ViewModel should handle the business logic and state management using `ObservableObject` and `@Published` properties. The View should observe these changes and update accordingly. The solution should demonstrate proper use of SwiftUI's state management tools, include proper data modeling with enums, and have a more refined UI with better organization than the beginner solution."
      },
      "advanced": {
        "name": "Advanced",
        "answer": "For an advanced implementation, we'll extend the MVVM pattern with dependency injection, unit testability, more advanced state management, and add features like temperature history and custom UI components.\n\n```swift\nimport SwiftUI\nimport Combine\n\n// MARK: - Models\n\nenum TemperatureUnit: Int, CaseIterable, Identifiable {\n    case celsius = 0\n    case fahrenheit = 1\n    case kelvin = 2\n    \n    var id: Int { self.rawValue }\n    \n    var symbol: String {\n        switch self {\n        case .celsius: return \"\u00b0C\"\n        case .fahrenheit: return \"\u00b0F\"\n        case .kelvin: return \"K\"\n        }\n    }\n    \n    var name: String {\n        switch self {\n        case .celsius: return \"Celsius\"\n        case .fahrenheit: return \"Fahrenheit\"\n        case .kelvin: return \"Kelvin\"\n        }\n    }\n}\n\nstruct TemperatureConversion: Identifiable {\n    let id = UUID()\n    let inputValue: Double\n    let inputUnit: TemperatureUnit\n    let date: Date\n    \n    var formattedInputValue: String {\n        return String(format: \"%.1f%@\", inputValue, inputUnit.symbol)\n    }\n    \n    func convertedValue(to targetUnit: TemperatureUnit) -> Double {\n        // First convert to Celsius as a common format\n        let celsius: Double\n        switch inputUnit {\n        case .celsius:\n            celsius = inputValue\n        case .fahrenheit:\n            celsius = (inputValue - 32) * 5/9\n        case .kelvin:\n            celsius = inputValue - 273.15\n        }\n        \n        // Then convert from Celsius to target unit\n        switch targetUnit {\n        case .celsius:\n            return celsius\n        case .fahrenheit:\n            return celsius * 9/5 + 32\n        case .kelvin:\n            return celsius + 273.15\n        }\n    }\n    \n    func formattedConvertedValue(to targetUnit: TemperatureUnit) -> String {\n        if targetUnit == inputUnit {\n            return \"Same unit\"\n        }\n        let value = convertedValue(to: targetUnit)\n        return String(format: \"%.1f%@\", value, targetUnit.symbol)\n    }\n}\n\n// MARK: - Services\n\nprotocol TemperatureHistoryService {\n    func saveConversion(_ conversion: TemperatureConversion)\n    func getRecentConversions(limit: Int) -> [TemperatureConversion]\n    func clearHistory()\n}\n\nclass LocalTemperatureHistoryService: TemperatureHistoryService {\n    private var history: [TemperatureConversion] = []\n    \n    func saveConversion(_ conversion: TemperatureConversion) {\n        history.append(conversion)\n    }\n    \n    func getRecentConversions(limit: Int) -> [TemperatureConversion] {\n        return Array(history.suffix(limit))\n    }\n    \n    func clearHistory() {\n        history.removeAll()\n    }\n}\n\n// MARK: - ViewModel\n\nclass TemperatureConverterViewModel: ObservableObject {\n    @Published var inputTemperature: String = \"\"\n    @Published var selectedInputUnit: TemperatureUnit = .celsius\n    @Published var selectedOutputUnit: TemperatureUnit = .fahrenheit\n    @Published var conversionHistory: [TemperatureConversion] = []\n    @Published var showingHistory = false\n    \n    private var cancellables = Set<AnyCancellable>()\n    private let historyService: TemperatureHistoryService\n    \n    var isValidInput: Bool {\n        Double(inputTemperature) != nil\n    }\n    \n    var convertedTemperature: String {\n        guard let inputValue = Double(inputTemperature) else {\n            return \"Invalid input\"\n        }\n        \n        if selectedInputUnit == selectedOutputUnit {\n            return \"Select different units\"\n        }\n        \n        let conversion = TemperatureConversion(\n            inputValue: inputValue,\n            inputUnit: selectedInputUnit,\n            date: Date()\n        )\n        \n        return conversion.formattedConvertedValue(to: selectedOutputUnit)\n    }\n    \n    init(historyService: TemperatureHistoryService = LocalTemperatureHistoryService()) {\n        self.historyService = historyService\n        \n        // Load initial history\n        loadHistory()\n        \n        // Set up publishers to auto-save conversions when valid\n        Publishers.CombineLatest3($inputTemperature, $selectedInputUnit, $selectedOutputUnit)\n            .debounce(for: .seconds(0.5), scheduler: RunLoop.main)\n            .sink { [weak self] inputTemp, inputUnit, outputUnit in\n                guard let self = self,\n                      let value = Double(inputTemp),\n                      inputUnit != outputUnit else { return }\n                \n                let conversion = TemperatureConversion(\n                    inputValue: value,\n                    inputUnit: inputUnit,\n                    date: Date()\n                )\n                \n                self.historyService.saveConversion(conversion)\n                self.loadHistory()\n            }\n            .store(in: &cancellables)\n    }\n    \n    func loadHistory() {\n        conversionHistory = historyService.getRecentConversions(limit: 5).reversed()\n    }\n    \n    func clearHistory() {\n        historyService.clearHistory()\n        conversionHistory = []\n    }\n    \n    func reset() {\n        inputTemperature = \"\"\n    }\n}\n\n// MARK: - Custom UI Components\n\nstruct TemperatureTextField: View {\n    @Binding var text: String\n    let placeholder: String\n    let isValid: Bool\n    \n    var body: some View {\n        TextField(placeholder, text: $text)\n            .keyboardType(.decimalPad)\n            .padding()\n            .background(\n                RoundedRectangle(cornerRadius: 8)\n                    .stroke(isValid ? Color.green : Color.red, lineWidth: text.isEmpty ? 0.5 : 2)\n            )\n            .padding(.horizontal)\n    }\n}\n\nstruct HistoryItemView: View {\n    let conversion: TemperatureConversion\n    let targetUnit: TemperatureUnit\n    \n    var body: some View {\n        HStack {\n            VStack(alignment: .leading) {\n                Text(conversion.formattedInputValue)\n                    .font(.headline)\n                Text(conversion.date, style: .time)\n                    .font(.caption)\n                    .foregroundColor(.secondary)\n            }\n            \n            Spacer()\n            \n            Text(\"\u2192\")\n                .font(.title2)\n                .foregroundColor(.secondary)\n            \n            Spacer()\n            \n            Text(conversion.formattedConvertedValue(to: targetUnit))\n                .font(.headline)\n        }\n        .padding()\n        .background(\n            RoundedRectangle(cornerRadius: 10)\n                .fill(Color(.systemBackground))\n                .shadow(color: Color.black.opacity(0.1), radius: 5, x: 0, y: 2)\n        )\n    }\n}\n\n// MARK: - Views\n\nstruct ContentView: View {\n    @StateObject private var viewModel = TemperatureConverterViewModel()\n    \n    var body: some View {\n        NavigationView {\n            ZStack {\n                Color(.systemGroupedBackground).edgesIgnoringSafeArea(.all)\n                \n                VStack(spacing: 20) {\n                    // Input Section\n                    GroupBox(label: Text(\"Input Temperature\").font(.headline)) {\n                        VStack {\n                            TemperatureTextField(\n                                text: $viewModel.inputTemperature,\n                                placeholder: \"Enter temperature\",\n                                isValid: viewModel.isValidInput || viewModel.inputTemperature.isEmpty\n                            )\n                            \n                            Picker(\"From\", selection: $viewModel.selectedInputUnit) {\n                                ForEach(TemperatureUnit.allCases) { unit in\n                                    Text(unit.name).tag(unit)\n                                }\n                            }\n                            .pickerStyle(SegmentedPickerStyle())\n                            .padding(.horizontal)\n                        }\n                        .padding(.vertical, 8)\n                    }\n                    .padding(.horizontal)\n                    \n                    // Output Section\n                    GroupBox(label: Text(\"Convert To\").font(.headline)) {\n                        VStack {\n                            Picker(\"To\", selection: $viewModel.selectedOutputUnit) {\n                                ForEach(TemperatureUnit.allCases) { unit in\n                                    Text(unit.name).tag(unit)\n                                }\n                            }\n                            .pickerStyle(SegmentedPickerStyle())\n                            .padding(.horizontal)\n                            \n                            Text(viewModel.convertedTemperature)\n                                .font(.system(size: 42, weight: .bold, design: .rounded))\n                                .foregroundColor(.blue)\n                                .padding()\n                                .frame(minHeight: 80)\n                        }\n                        .padding(.vertical, 8)\n                    }\n                    .padding(.horizontal)\n                    \n                    // Controls\n                    HStack {\n                        Button(action: viewModel.reset) {\n                            Label(\"Reset\", systemImage: \"arrow.counterclockwise\")\n                        }\n                        .buttonStyle(.bordered)\n                        \n                        Spacer()\n                        \n                        Button(action: { viewModel.showingHistory.toggle() }) {\n                            Label(\"History\", systemImage: \"clock.arrow.circlepath\")\n                        }\n                        .buttonStyle(.bordered)\n                    }\n                    .padding(.horizontal)\n                    \n                    // History Section (if enabled)\n                    if viewModel.showingHistory {\n                        GroupBox(label: \n                            HStack {\n                                Text(\"Recent Conversions\").font(.headline)\n                                Spacer()\n                                Button(action: viewModel.clearHistory) {\n                                    Text(\"Clear\")\n                                        .font(.caption)\n                                        .foregroundColor(.red)\n                                }\n                            }\n                        ) {\n                            if viewModel.conversionHistory.isEmpty {\n                                Text(\"No conversion history\")\n                                    .foregroundColor(.secondary)\n                                    .padding()\n                            } else {\n                                ScrollView {\n                                    LazyVStack(spacing: 10) {\n                                        ForEach(viewModel.conversionHistory) { conversion in\n                                            HistoryItemView(\n                                                conversion: conversion,\n                                                targetUnit: viewModel.selectedOutputUnit\n                                            )\n                                        }\n                                    }\n                                    .padding(.vertical, 8)\n                                }\n                                .frame(maxHeight: 300)\n                            }\n                        }\n                        .padding(.horizontal)\n                    }\n                    \n                    Spacer()\n                }\n                .padding(.vertical)\n            }\n            .navigationTitle(\"Temperature Converter\")\n            .toolbar {\n                ToolbarItem(placement: .keyboard) {\n                    Button(\"Done\") {\n                        UIApplication.shared.sendAction(#selector(UIResponder.resignFirstResponder), \n                                                       to: nil, from: nil, for: nil)\n                    }\n                }\n            }\n        }\n    }\n}\n```\n\nThis advanced implementation includes:\n\n1. **Enhanced MVVM Architecture**: Clear separation of Model, View, and ViewModel with proper dependency injection.\n\n2. **Protocol-based Services**: A history service defined by a protocol for better testability and flexibility.\n\n3. **Reactive Programming**: Using Combine to automatically save conversions when valid input changes occur.\n\n4. **Advanced Data Model**: A more sophisticated model for temperature conversions that supports multiple units and stores conversion history.\n\n5. **Custom UI Components**: Reusable SwiftUI components for text fields and history items.\n\n6. **Improved UX**: A more polished UI with GroupBox, better visual feedback, and a keyboard dismissal button.\n\n7. **History Feature**: Tracking and displaying recent temperature conversions.\n\n8. **Input Validation**: Visual feedback for valid/invalid inputs.",
        "tests": [
          {
            "snippet": "What is the benefit of using a protocol for the TemperatureHistoryService?",
            "options": [
              "1. It allows us to use any implementation that conforms to the protocol, making the code more testable",
              "2. Protocols are required for all SwiftUI applications",
              "3. It makes the code run faster by optimizing the compiler"
            ],
            "answer": "1"
          },
          {
            "snippet": "In the advanced implementation, what is the purpose of the `.debounce(for: .seconds(0.5), scheduler: RunLoop.main)` operator in the Combine pipeline?",
            "options": [
              "1. It delays the execution of the whole app by 0.5 seconds",
              "2. It waits until the user has stopped typing for 0.5 seconds before processing the input",
              "3. It makes the UI update exactly every 0.5 seconds"
            ],
            "answer": "2"
          },
          {
            "snippet": "If we wanted to add persistence to save the conversion history between app launches, which would be the most appropriate approach?",
            "options": [
              "1. Create a new implementation of TemperatureHistoryService that uses UserDefaults or Core Data",
              "2. Add a static variable to the ContentView to store the history",
              "3. Use @AppStorage for each individual conversion in the history"
            ],
            "answer": "1"
          }
        ],
        "evaluationCriteria": "The advanced solution should demonstrate comprehensive knowledge of SwiftUI and state management patterns. It should implement a robust MVVM architecture with proper dependency injection and separation of concerns. The solution should use protocols for services to enable testability, employ reactive programming with Combine for complex state updates, include custom UI components, and feature a polished user interface with enhanced functionality like conversion history. Code should be clean, well-organized, and follow best practices for maintainability and scalability."
      }
    }
  }
}