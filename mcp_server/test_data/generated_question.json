{
  "agent": {
    "model": {
      "provider": "openai",
      "model": "o4-mini"
    },
    "statistic": {
      "time": 72663,
      "tokens": 9067
    }
  },
  "question": {
    "topic": {
      "name": "SwiftUI State and Binding",
      "platform": "iOS",
      "technology": "Swift"
    },
    "text": "You need to create a reusable Stepper component in SwiftUI that can increase or decrease an integer value. This component should communicate its value changes back to a parent view using bindings. Implement StepperView with proper use of @State and @Binding, and explain how data flows between parent and child views. Highlight how SwiftUI updates the UI when state changes and describe common pitfalls.",
    "tags": [
      "SwiftUI",
      "State",
      "Binding",
      "View",
      "iOS",
      "Property Wrappers"
    ],
    "answerLevels": {
      "beginner": {
        "name": "Beginner",
        "answer": "At the Beginner level, you define a local state property in your view using @State. This property holds the current value and SwiftUI observes it for changes. You can bind this property to built-in controls such as Toggle, Slider, or Stepper by prefixing it with $. When the control modifies the binding, SwiftUI updates the state and recomputes the view. Example:\n\n```swift\nstruct ContentView: View {\n    @State private var count: Int = 0\n\n    var body: some View {\n        VStack {\n            Text(\"Count: \\(count)\")\n            Stepper(\"Increment\", value: $count)\n        }\n    }\n}\n```\n\nThis simple setup demonstrates how @State and bindings work together to keep the UI and data in sync.",
        "tests": [
          {
            "snippet": "```swift\nstruct ContentView: View {\n    @State var isOn: Bool = false\n    var body: some View {\n        Toggle(\"Enable\", isOn: $isOn)\n    }\n}\n``` Which property wrapper is used to declare a mutable state?",
            "options": [
              "1. @Binding",
              "2. @State",
              "3. @ObservedObject",
              "4. @EnvironmentObject"
            ],
            "answer": "2"
          },
          {
            "snippet": "```swift\n@State private var count: Int = 0\ncount += 1\n``` What happens when 'count' is modified in SwiftUI?",
            "options": [
              "1. The view updates to reflect the new state",
              "2. Nothing happens at runtime",
              "3. Compile-time error",
              "4. Memory leak occurs"
            ],
            "answer": "1"
          },
          {
            "snippet": "```swift\nstruct ParentView: View {\n    @State private var count = 0\n    var body: some View {\n        ChildView(count: count)\n    }\n}\n``` How should you pass 'count' to ChildView to allow two-way updates?",
            "options": [
              "1. ChildView(count: count)",
              "2. ChildView(count: $count)",
              "3. ChildView(count: Binding.count)",
              "4. ChildView(count: .constant(count))"
            ],
            "answer": "2"
          }
        ],
        "evaluation_criteria": "At the Beginner level, the student should understand basic use of @State and how to bind it to controls. They should be able to read and write simple SwiftUI views, identify property wrappers, and predict how state changes drive UI updates."
      },
      "intermediate": {
        "name": "Intermediate",
        "answer": "To create a reusable StepperView, define a view that accepts a binding to an Int. Use @Binding to declare the binding, and pass $count from the parent. The view can then modify the binding directly. Example:\n\n```swift\nstruct StepperView: View {\n    @Binding var value: Int\n\n    var body: some View {\n        HStack {\n            Button(action: { value -= 1 }) {\n                Image(systemName: \"minus.circle\")\n            }\n            Text(\"\\(value)\")\n                .frame(minWidth: 40)\n            Button(action: { value += 1 }) {\n                Image(systemName: \"plus.circle\")\n            }\n        }\n    }\n}\n\nstruct ContentView: View {\n    @State private var count = 0\n\n    var body: some View {\n        StepperView(value: $count)\n    }\n}\n```\n\nThis example shows how to declare @Binding, pass the binding from the parent, and mutate the value so SwiftUI automatically updates both views.",
        "tests": [
          {
            "snippet": "```swift\nstruct StepperView: View {\n    var value: Int\n    var body: some View {\n        HStack {\n            Button(\"-\") { value -= 1 }\n            Text(\"\\(value)\")\n            Button(\"+\") { value += 1 }\n        }\n    }\n}\n``` Why does this code fail to compile?",
            "options": [
              "1. View body must be a computed property",
              "2. Buttons require explicit action closures",
              "3. Missing @State property wrapper",
              "4. Missing @Binding property wrapper"
            ],
            "answer": "4"
          },
          {
            "snippet": "```swift\nstruct ContentView: View {\n    @State private var count = 0\n    var body: some View {\n        StepperView(value: count)\n    }\n}\n``` What change fixes the two-way data flow?",
            "options": [
              "1. Use @ObservedObject instead of @State",
              "2. Pass $count instead of count",
              "3. Initialize StepperView with .constant",
              "4. Change count to @Binding"
            ],
            "answer": "2"
          },
          {
            "snippet": "```swift\nstruct StepperView: View {\n    @Binding var value: Int\n    var body: some View {\n        Stepper(value: $value, in: 0...10) {\n            Text(\"Value: \\(value)\")\n        }\n    }\n}\n``` How does the Stepper control update 'value'?",
            "options": [
              "1. Directly sets a published property",
              "2. Uses the binding to write the new value back to the parent",
              "3. Calls an onChange observer",
              "4. Triggers an environment update"
            ],
            "answer": "2"
          }
        ],
        "evaluation_criteria": "At the Intermediate level, the student should understand custom component design with @Binding, passing data between views, and common compile errors. They should demonstrate ability to read and debug binding-related code, and understand how parent and child views share and mutate state."
      },
      "advanced": {
        "name": "Advanced",
        "answer": "At the Advanced level, you can create computed bindings that transform values, manage state across multiple views, and optimize performance. SwiftUI's Binding init(get:set:) lets you derive a new binding. You can also use @StateObject or @ObservedObject for shared data models and handle side effects with onChange. Example:\n\n```swift\nclass CounterModel: ObservableObject {\n    @Published var count: Int = 0\n}\n\nstruct ContentView: View {\n    @StateObject private var model = CounterModel()\n\n    private var doubledBinding: Binding<Int> {\n        Binding(\n            get: { model.count * 2 },\n            set: { model.count = $0 / 2 }\n        )\n    }\n\n    var body: some View {\n        VStack {\n            Text(\"Double: \\(doubledBinding.wrappedValue)\")\n            Stepper(\"Double\", value: doubledBinding)\n        }\n        .onChange(of: model.count) { newValue in\n            print(\"Count changed to \\(newValue)\")\n        }\n    }\n}\n```\n\nThis shows use of @StateObject for lifecycle, computed binding to transform values, and onChange for side effects. Such patterns help manage complex data flows and optimize view updates.",
        "tests": [
          {
            "snippet": "```swift\nlet binding = Binding(\n    get: { self.count * 2 },\n    set: { self.count = $0 / 2 }\n)\n``` What is this binding doing?",
            "options": [
              "1. Creating a derived binding that converts raw values",
              "2. Declaring an environment object",
              "3. Observing object changes",
              "4. Defining an animation"
            ],
            "answer": "1"
          },
          {
            "snippet": "```swift\nclass Counter: ObservableObject {\n    @Published var count: Int = 0\n}\n\nstruct ViewA: View {\n    @ObservedObject var counter = Counter()\n    // ...\n}\n``` What role does @Published play?",
            "options": [
              "1. Enables basic state property",
              "2. Notifies observers of changes",
              "3. Forces view reload on initialization",
              "4. Prevents memory leaks"
            ],
            "answer": "2"
          },
          {
            "snippet": "```swift\n.onChange(of: value) { newValue in\n    self.value = min(max(newValue, 0), 10)\n}\n``` Why use onChange here?",
            "options": [
              "1. To animate value changes",
              "2. To validate and clamp input values",
              "3. To avoid memory leaks",
              "4. To publish values externally"
            ],
            "answer": "2"
          }
        ],
        "evaluation_criteria": "At the Advanced level, the student should demonstrate deep understanding of SwiftUI data flow, custom bindings, and state management patterns. They should be able to create derived bindings, use @StateObject and @ObservedObject correctly, handle side effects with onChange, and optimize complex views."
      }
    }
  }
}