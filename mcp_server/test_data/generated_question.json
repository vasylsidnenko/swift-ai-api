{
  "agent": {
    "model": {
      "provider": "openai",
      "model": "gpt-4o-mini"
    },
    "statistic": {
      "time": 35512,
      "tokens": 5021
    }
  },
  "question": {
    "topic": {
      "name": "SwiftUI",
      "platform": "iOS",
      "technology": "Swift"
    },
    "text": "Create a simple SwiftUI application that displays a list of items with a toggle switch for each item. The toggle should indicate whether the item is active or inactive. When the toggle is changed, the app should reflect this change visually and in the data model. Use State and Binding to manage the state of the toggles. Provide code for the view and the model.",
    "tags": [
      "SwiftUI",
      "View",
      "State",
      "Binding",
      "iOS",
      "Swift"
    ],
    "answerLevels": {
      "beginner": {
        "name": "Beginner",
        "answer": "To create a simple SwiftUI application that displays a list with toggle switches, we start by defining a model for the items. Each item will have a name and an active state. We can then create a SwiftUI view that displays each item with its corresponding toggle. Using @State, we can manage the list of items and their active states. Here\u2019s a simple implementation:\n\n```swift\nimport SwiftUI\n\nstruct Item {\n    let name: String\n    var isActive: Bool\n}\n\nstruct ContentView: View {\n    @State private var items = [\n        Item(name: \"Item 1\", isActive: true),\n        Item(name: \"Item 2\", isActive: false),\n        Item(name: \"Item 3\", isActive: true)\n    ]\n\n    var body: some View {\n        List {\n            ForEach(0..<items.count, id: \\ .self) { index in\n                HStack {\n                    Text(items[index].name)\n                    Toggle(isOn: Binding(\n                        get: { items[index].isActive },\n                        set: { items[index].isActive = $0 }\n                    )) {\n                        Text(\"\")\n                    }\n                }\n            }\n        }\n    }\n}\n\nstruct ContentView_Previews: PreviewProvider {\n    static var previews: some View {\n        ContentView()\n    }\n}\n```",
        "tests": [
          {
            "snippet": "```swift\nstruct Item {\n    let name: String\n    var isActive: Bool\n}\n\nlet item = Item(name: \"Test\", isActive: true)\nitem.isActive = false // This line will cause an error\n```",
            "options": [
              "1. True",
              "2. False",
              "3. It will compile without errors",
              "4. The item will not change its state"
            ],
            "answer": "2"
          },
          {
            "snippet": "```swift\n@State private var items: [Item]\n```",
            "options": [
              "1. A property that cannot be mutated",
              "2. A way to store data that can change",
              "3. A constant array",
              "4. Used for static data"
            ],
            "answer": "2"
          },
          {
            "snippet": "```swift\nToggle(isOn: $isActive) {\n    Text(\"Active\")\n}\n```",
            "options": [
              "1. Binds a toggle to a local state variable",
              "2. Creates a static toggle",
              "3. Does not change the item state",
              "4. Only works in UIKit"
            ],
            "answer": "1"
          }
        ],
        "evaluation_criteria": "At the Beginner level, the student should understand basic syntax and fundamental concepts of SwiftUI. They should demonstrate the ability to read simple code examples, identify correct syntax, and understand basic programming patterns related to SwiftUI on iOS."
      },
      "intermediate": {
        "name": "Intermediate",
        "answer": "In the intermediate level, we expand the functionality by allowing users to add and remove items from the list dynamically. We still use State and Binding to manage the state of the list. Here\u2019s how we can achieve this:\n\n```swift\nimport SwiftUI\n\nstruct Item {\n    let name: String\n    var isActive: Bool\n}\n\nstruct ContentView: View {\n    @State private var items: [Item] = []\n    @State private var newItemName: String = \"\"\n\n    var body: some View {\n        VStack {\n            TextField(\"New Item\", text: $newItemName)\n                .textFieldStyle(RoundedBorderTextFieldStyle())\n                .padding()\n            Button(\"Add Item\") {\n                let newItem = Item(name: newItemName, isActive: false)\n                items.append(newItem)\n                newItemName = \"\"\n            }\n            List {\n                ForEach(0..<items.count, id: \\ .self) { index in\n                    HStack {\n                        Text(items[index].name)\n                        Toggle(isOn: Binding(\n                            get: { items[index].isActive },\n                            set: { items[index].isActive = $0 }\n                        )) {\n                            Text(\"\")\n                        }\n                    }\n                }\n                .onDelete(perform: deleteItem)\n            }\n        }\n    }\n\n    func deleteItem(at offsets: IndexSet) {\n        items.remove(atOffsets: offsets)\n    }\n}\n\nstruct ContentView_Previews: PreviewProvider {\n    static var previews: some View {\n        ContentView()\n    }\n}\n```",
        "tests": [
          {
            "snippet": "```swift\nitems.append(newItem)\n```",
            "options": [
              "1. Adds an item to the beginning of the list",
              "2. Adds an item to the end of the list",
              "3. Overwrites an existing item",
              "4. Does nothing"
            ],
            "answer": "2"
          },
          {
            "snippet": "```swift\n@State private var newItemName: String = \"\"\n```",
            "options": [
              "1. A variable that stores the name of the last item added",
              "2. A constant string variable",
              "3. A variable that binds to the text field for new item names",
              "4. A global variable"
            ],
            "answer": "3"
          },
          {
            "snippet": "```swift\n.onDelete(perform: deleteItem)\n```",
            "options": [
              "1. Used to edit items",
              "2. Used to delete items from the list",
              "3. Used to add new items",
              "4. Does nothing"
            ],
            "answer": "2"
          }
        ],
        "evaluation_criteria": "At the Intermediate level, the student should understand more complex implementations and common design patterns related to SwiftUI. They should demonstrate the ability to analyze code, identify potential issues, and understand the practical applications of SwiftUI concepts in iOS development."
      },
      "advanced": {
        "name": "Advanced",
        "answer": "At the advanced level, we will implement more advanced features such as persistence using UserDefaults to save the state of the items. Additionally, we will use ObservableObject and @Published to manage the state more cleanly.\n\n```swift\nimport SwiftUI\nimport Combine\n\nclass ItemStore: ObservableObject {\n    @Published var items: [Item] {\n        didSet {\n            saveItems()\n        }\n    }\n\n    init() {\n        self.items = UserDefaults.standard.array(forKey: \"items\") as? [Item] ?? []\n    }\n\n    func saveItems() {\n        UserDefaults.standard.set(items, forKey: \"items\")\n    }\n}\n\nstruct ContentView: View {\n    @ObservedObject var store = ItemStore()\n    @State private var newItemName: String = \"\"\n\n    var body: some View {\n        VStack {\n            TextField(\"New Item\", text: $newItemName)\n                .textFieldStyle(RoundedBorderTextFieldStyle())\n                .padding()\n            Button(\"Add Item\") {\n                let newItem = Item(name: newItemName, isActive: false)\n                store.items.append(newItem)\n                newItemName = \"\"\n            }\n            List {\n                ForEach(0..<store.items.count, id: \\ .self) { index in\n                    HStack {\n                        Text(store.items[index].name)\n                        Toggle(isOn: Binding(\n                            get: { store.items[index].isActive },\n                            set: { store.items[index].isActive = $0 }\n                        )) {\n                            Text(\"\")\n                        }\n                    }\n                }\n                .onDelete(perform: deleteItem)\n            }\n        }\n    }\n\n    func deleteItem(at offsets: IndexSet) {\n        store.items.remove(atOffsets: offsets)\n    }\n}\n\nstruct ContentView_Previews: PreviewProvider {\n    static var previews: some View {\n        ContentView()\n    }\n}\n```",
        "tests": [
          {
            "snippet": "```swift\n@Published var items: [Item]\n```",
            "options": [
              "1. A property that notifies views of changes",
              "2. A property that is static",
              "3. A property that cannot change",
              "4. A private property"
            ],
            "answer": "1"
          },
          {
            "snippet": "```swift\nUserDefaults.standard.set(items, forKey: \"items\")\n```",
            "options": [
              "1. Saves data to the user's documents directory",
              "2. Saves data to persistent storage",
              "3. Does not save data",
              "4. Saves data to the temporary directory"
            ],
            "answer": "2"
          },
          {
            "snippet": "```swift\n@ObservedObject var store = ItemStore()\n```",
            "options": [
              "1. Creates a new instance of ItemStore every time",
              "2. Observes changes in ItemStore",
              "3. Is not necessary in SwiftUI",
              "4. Creates a static instance of ItemStore"
            ],
            "answer": "2"
          }
        ],
        "evaluation_criteria": "At the Advanced level, the student should demonstrate deep understanding of SwiftUI internals and optimization techniques. They should be able to evaluate complex implementations, understand performance implications, and apply advanced patterns related to SwiftUI in sophisticated iOS applications."
      }
    }
  }
}